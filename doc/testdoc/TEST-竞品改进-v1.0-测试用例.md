# 甘特图编辑器改进计划 - 单元测试用例文档

> 版本：v1.0
> 更新日期：2026-01-17
> 对应PRD：Gantt Editor Evolution v1.0

---

## 目录

1. [性能优化模块 (Performance)](#1-性能优化模块-performance)
2. [智能调度引擎模块 (Auto-Scheduling)](#2-智能调度引擎模块-auto-scheduling)
3. [移动端适配模块 (Mobile Responsive)](#3-移动端适配模块-mobile-responsive)
4. [交互体验优化模块 (UX Improvements)](#4-交互体验优化模块-ux-improvements)

---

## 1. 性能优化模块 (Performance)

### 1.1 智能渲染

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-001 |
| **所属模块** | 性能优化 / 智能渲染 |
| **测试场景** | 验证智能渲染配置是否正确启用 |
| **前置条件** | 甘特图组件已初始化 |
| **测试步骤** | 1. 获取 `gantt.config.smart_rendering` 配置值<br>2. 检查配置是否为 `true` |
| **预期结果** | `gantt.config.smart_rendering === true` |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-002 |
| **所属模块** | 性能优化 / 智能渲染 |
| **测试场景** | 验证视口外的任务不生成 DOM 元素 |
| **前置条件** | 1. 加载 1000+ 任务数据<br>2. 视口高度仅能显示 20 个任务 |
| **测试步骤** | 1. 初始化甘特图并加载数据<br>2. 统计当前渲染的任务行 DOM 数量<br>3. 对比视口可见任务数与实际 DOM 数量 |
| **预期结果** | 渲染的 DOM 元素数量 ≈ 视口可见任务数（允许上下各有少量缓冲），远小于总任务数 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-003 |
| **所属模块** | 性能优化 / 智能渲染 |
| **测试场景** | 验证滚动时动态渲染视口内任务 |
| **前置条件** | 1. 加载 1000 个任务<br>2. 当前视口显示任务 1-20 |
| **测试步骤** | 1. 记录当前渲染的任务 ID 列表<br>2. 滚动到任务 500-520 区域<br>3. 记录滚动后渲染的任务 ID 列表 |
| **预期结果** | 滚动后 DOM 中的任务 ID 变为 500-520 区域的任务，原 1-20 区域的任务 DOM 被回收 |
| **优先级** | P0 |

---

### 1.2 防抖处理

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-004 |
| **所属模块** | 性能优化 / 防抖处理 |
| **测试场景** | 验证拖拽过程中仅更新 Ghost 元素 |
| **前置条件** | 1. 存在任务 A<br>2. 监听重绘事件 |
| **测试步骤** | 1. 开始拖拽任务 A<br>2. 拖拽过程中记录重绘触发次数<br>3. 检查 Ghost 元素是否跟随鼠标移动 |
| **预期结果** | 1. 拖拽过程中重绘次数为 0<br>2. Ghost 元素位置实时更新 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-005 |
| **所属模块** | 性能优化 / 防抖处理 |
| **测试场景** | 验证 onAfterTaskDrag 触发统一重绘 |
| **前置条件** | 1. 存在任务 A<br>2. 监听 `onAfterTaskDrag` 事件 |
| **测试步骤** | 1. 拖拽任务 A 到新位置<br>2. 释放鼠标完成拖拽<br>3. 检查 `onAfterTaskDrag` 是否触发<br>4. 检查重绘是否执行 |
| **预期结果** | 1. `onAfterTaskDrag` 事件触发一次<br>2. 甘特图完成一次完整重绘<br>3. 任务位置更新正确 |
| **优先级** | P0 |

---

### 1.3 DOM 复用

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-006 |
| **所属模块** | 性能优化 / DOM 复用 |
| **测试场景** | 验证 Grid 行 DOM 元素复用 |
| **前置条件** | 1. 加载 100 个任务<br>2. 视口显示 20 个任务 |
| **测试步骤** | 1. 记录当前 Grid 行 DOM 元素引用<br>2. 滚动一屏<br>3. 检查新视口中的 DOM 元素是否复用了原有元素 |
| **预期结果** | 部分 DOM 元素被复用（相同的 DOM 节点引用），而非全部销毁重建 |
| **优先级** | P0 |

---

### 1.4 性能基准测试

| 字段 | 内容 |
|------|------|
| **用例编号** | PERF-007 |
| **所属模块** | 性能优化 / 基准测试 |
| **测试场景** | 验证 1000 任务场景下 FPS ≥ 50 |
| **前置条件** | 1. 生成 1000 个任务的 Mock 数据<br>2. 启用 FPS 监控工具 |
| **测试步骤** | 1. 加载 1000 个任务<br>2. 执行连续滚动操作 5 秒<br>3. 执行拖拽操作 5 次<br>4. 记录整个过程的平均 FPS |
| **预期结果** | 平均 FPS ≥ 50 |
| **优先级** | P0 |

---

## 2. 智能调度引擎模块 (Auto-Scheduling)

### 2.1 级联更新

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-001 |
| **所属模块** | 智能调度 / 级联更新 |
| **测试场景** | 验证 FS 依赖下前置任务延长自动推迟后继任务 |
| **前置条件** | 1. 任务 A：开始 1/1，结束 1/5<br>2. 任务 B：开始 1/6，结束 1/10<br>3. 存在依赖 A -> B (FS) |
| **测试步骤** | 1. 修改任务 A 结束时间为 1/8<br>2. 触发调度引擎计算<br>3. 获取任务 B 的新开始时间 |
| **预期结果** | 任务 B 开始时间自动更新为 1/9（A 结束后第一个工作日） |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-002 |
| **所属模块** | 智能调度 / 级联更新 |
| **测试场景** | 验证多级级联更新 |
| **前置条件** | 1. 任务链：A -> B -> C (均为 FS 依赖)<br>2. 各任务工期均为 3 天 |
| **测试步骤** | 1. 延长任务 A 结束时间 5 天<br>2. 触发调度引擎<br>3. 检查 B 和 C 的时间变化 |
| **预期结果** | 任务 B 和任务 C 均自动后延 5 个工作日 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-003 |
| **所属模块** | 智能调度 / 级联更新 |
| **测试场景** | 验证缩短前置任务不影响后继任务 |
| **前置条件** | 1. 任务 A：结束 1/10<br>2. 任务 B：开始 1/15 (存在 5 天间隔)<br>3. 依赖 A -> B (FS) |
| **测试步骤** | 1. 将任务 A 结束时间提前到 1/5<br>2. 触发调度引擎<br>3. 检查任务 B 的开始时间 |
| **预期结果** | 任务 B 开始时间保持 1/15 不变（仅推迟不提前，除非显式启用） |
| **优先级** | P0 |

---

### 2.2 工作日历

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-004 |
| **所属模块** | 智能调度 / 工作日历 |
| **测试场景** | 验证 work_time 配置正确启用 |
| **前置条件** | 甘特图组件已初始化 |
| **测试步骤** | 1. 获取 `gantt.config.work_time` 配置值 |
| **预期结果** | `gantt.config.work_time === true` |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-005 |
| **所属模块** | 智能调度 / 工作日历 |
| **测试场景** | 验证级联更新跳过周末 |
| **前置条件** | 1. 任务 A：结束时间为周五 (如 1/10)<br>2. 任务 B：依赖 A (FS)<br>3. 1/11、1/12 为周末 |
| **测试步骤** | 1. 设置任务 A 结束时间为周五 1/10<br>2. 触发调度引擎计算 B 的开始时间 |
| **预期结果** | 任务 B 开始时间为下周一 1/13，跳过周末 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-006 |
| **所属模块** | 智能调度 / 工作日历 |
| **测试场景** | 验证工期计算跳过周末 |
| **前置条件** | 1. 创建新任务<br>2. 开始时间：周四<br>3. 工期：3 个工作日 |
| **测试步骤** | 1. 创建任务，开始时间周四，工期 3 天<br>2. 计算结束时间 |
| **预期结果** | 结束时间为下周一（周四、周五、下周一共 3 个工作日） |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-007 |
| **所属模块** | 智能调度 / 工作日历 |
| **测试场景** | 验证周六被正确识别为非工作日 |
| **前置条件** | 工作日历已配置 |
| **测试步骤** | 1. 调用 `isWorkDay(周六日期)` 方法 |
| **预期结果** | 返回 `false` |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-008 |
| **所属模块** | 智能调度 / 工作日历 |
| **测试场景** | 验证周日被正确识别为非工作日 |
| **前置条件** | 工作日历已配置 |
| **测试步骤** | 1. 调用 `isWorkDay(周日日期)` 方法 |
| **预期结果** | 返回 `false` |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-009 |
| **所属模块** | 智能调度 / 工作日历 |
| **测试场景** | 验证工作日被正确识别 |
| **前置条件** | 工作日历已配置 |
| **测试步骤** | 1. 调用 `isWorkDay(周一至周五的日期)` 方法 |
| **预期结果** | 返回 `true` |
| **优先级** | P0 |

---

### 2.3 父任务自动聚合 (WBS Calculation)

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-010 |
| **所属模块** | 智能调度 / 父任务聚合 |
| **测试场景** | 验证父任务开始时间等于最早子任务开始时间 |
| **前置条件** | 1. 父任务 P 包含子任务 A、B、C<br>2. A：1/5-1/10，B：1/1-1/8，C：1/8-1/15 |
| **测试步骤** | 1. 获取父任务 P 的开始时间 |
| **预期结果** | 父任务 P 开始时间 = 1/1（子任务 B 的开始时间，最早） |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-011 |
| **所属模块** | 智能调度 / 父任务聚合 |
| **测试场景** | 验证父任务结束时间等于最晚子任务结束时间 |
| **前置条件** | 1. 父任务 P 包含子任务 A、B、C<br>2. A：1/5-1/10，B：1/1-1/8，C：1/8-1/15 |
| **测试步骤** | 1. 获取父任务 P 的结束时间 |
| **预期结果** | 父任务 P 结束时间 = 1/15（子任务 C 的结束时间，最晚） |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-012 |
| **所属模块** | 智能调度 / 父任务聚合 |
| **测试场景** | 验证子任务延长后父任务自动撑大 |
| **前置条件** | 1. 父任务 P：1/1-1/15<br>2. 子任务 A：1/10-1/15 |
| **测试步骤** | 1. 将子任务 A 结束时间改为 1/20<br>2. 检查父任务 P 的结束时间 |
| **预期结果** | 父任务 P 结束时间自动更新为 1/20 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-013 |
| **所属模块** | 智能调度 / 父任务聚合 |
| **测试场景** | 验证子任务缩短后父任务自动收缩 |
| **前置条件** | 1. 父任务 P：1/1-1/20<br>2. 子任务 A：1/1-1/10，B：1/5-1/20 |
| **测试步骤** | 1. 将子任务 B 结束时间改为 1/12<br>2. 检查父任务 P 的结束时间 |
| **预期结果** | 父任务 P 结束时间自动更新为 1/12（新的最晚结束时间） |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-014 |
| **所属模块** | 智能调度 / 父任务聚合 |
| **测试场景** | 验证禁止直接修改父任务时间 |
| **前置条件** | 1. 父任务 P 包含子任务<br>2. 父任务时间由子任务决定 |
| **测试步骤** | 1. 尝试直接修改父任务 P 的开始时间<br>2. 检查修改是否被阻止或回滚 |
| **预期结果** | 1. 修改被阻止（返回错误/警告）或被回滚<br>2. 父任务时间保持由子任务决定 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-015 |
| **所属模块** | 智能调度 / 父任务聚合 |
| **测试场景** | 验证多层嵌套父任务聚合 |
| **前置条件** | 1. 祖父任务 GP -> 父任务 P -> 子任务 A<br>2. A：1/5-1/10 |
| **测试步骤** | 1. 将子任务 A 结束时间改为 1/20<br>2. 检查父任务 P 和祖父任务 GP 的结束时间 |
| **预期结果** | P 和 GP 的结束时间均更新为 1/20 |
| **优先级** | P0 |

---

### 2.4 扩展依赖类型

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-016 |
| **所属模块** | 智能调度 / 依赖类型 |
| **测试场景** | 验证 FS (Finish-to-Start) 依赖基本逻辑 |
| **前置条件** | 1. 任务 A：1/1-1/5<br>2. 任务 B：待计算<br>3. 依赖：A -> B (FS) |
| **测试步骤** | 1. 创建 FS 依赖关系<br>2. 触发调度计算<br>3. 获取任务 B 的可开始时间 |
| **预期结果** | 任务 B 最早开始时间 = 任务 A 结束时间 + 1 工作日 = 1/6 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-017 |
| **所属模块** | 智能调度 / 依赖类型 |
| **测试场景** | 验证 SS (Start-to-Start) 依赖基本逻辑 |
| **前置条件** | 1. 任务 A：开始 1/5<br>2. 任务 B：待计算<br>3. 依赖：A -> B (SS) |
| **测试步骤** | 1. 创建 SS 依赖关系<br>2. 触发调度计算<br>3. 获取任务 B 的可开始时间 |
| **预期结果** | 任务 B 最早开始时间 = 任务 A 开始时间 = 1/5 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-018 |
| **所属模块** | 智能调度 / 依赖类型 |
| **测试场景** | 验证 SS 依赖下前置任务开始时间变更的级联 |
| **前置条件** | 1. 任务 A：开始 1/5<br>2. 任务 B：开始 1/5<br>3. 依赖：A -> B (SS) |
| **测试步骤** | 1. 修改任务 A 开始时间为 1/10<br>2. 触发调度引擎<br>3. 检查任务 B 的开始时间 |
| **预期结果** | 任务 B 开始时间自动更新为 1/10 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-019 |
| **所属模块** | 智能调度 / 依赖类型 |
| **测试场景** | 验证 SS 依赖结合 Lag 的计算 |
| **前置条件** | 1. 任务 A：开始 1/5<br>2. 任务 B：待计算<br>3. 依赖：A -> B (SS, Lag=2 天) |
| **测试步骤** | 1. 创建 SS 依赖并设置 Lag=2<br>2. 触发调度计算<br>3. 获取任务 B 的开始时间 |
| **预期结果** | 任务 B 开始时间 = 1/7（A 开始后 2 个工作日） |
| **优先级** | P0 |

---

### 2.5 循环检测

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-020 |
| **所属模块** | 智能调度 / 循环检测 |
| **测试场景** | 验证直接循环依赖被阻止 |
| **前置条件** | 1. 任务 A 和任务 B 已存在<br>2. 已存在依赖 A -> B |
| **测试步骤** | 1. 尝试创建依赖 B -> A<br>2. 检查操作结果 |
| **预期结果** | 1. 依赖创建被阻止<br>2. 返回错误提示"检测到循环依赖" |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-021 |
| **所属模块** | 智能调度 / 循环检测 |
| **测试场景** | 验证间接循环依赖被阻止 (3 节点) |
| **前置条件** | 1. 存在依赖链 A -> B -> C |
| **测试步骤** | 1. 尝试创建依赖 C -> A<br>2. 检查操作结果 |
| **预期结果** | 1. 依赖创建被阻止<br>2. 返回错误提示"检测到循环依赖" |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-022 |
| **所属模块** | 智能调度 / 循环检测 |
| **测试场景** | 验证自依赖被阻止 |
| **前置条件** | 任务 A 已存在 |
| **测试步骤** | 1. 尝试创建依赖 A -> A<br>2. 检查操作结果 |
| **预期结果** | 1. 依赖创建被阻止<br>2. 返回错误提示 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-023 |
| **所属模块** | 智能调度 / 循环检测 |
| **测试场景** | 验证复杂间接循环被检测 (5+ 节点) |
| **前置条件** | 存在依赖链 A -> B -> C -> D -> E |
| **测试步骤** | 1. 尝试创建依赖 E -> A<br>2. 检查操作结果 |
| **预期结果** | 1. 循环被正确检测<br>2. 依赖创建被阻止 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-024 |
| **所属模块** | 智能调度 / 循环检测 |
| **测试场景** | 验证合法依赖链可正常创建 |
| **前置条件** | 任务 A、B、C 无依赖关系 |
| **测试步骤** | 1. 创建依赖 A -> B<br>2. 创建依赖 B -> C<br>3. 检查依赖关系 |
| **预期结果** | 两个依赖均创建成功，无错误提示 |
| **优先级** | P0 |

---

### 2.6 Buffer/Lag 支持

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-025 |
| **所属模块** | 智能调度 / Lag 支持 |
| **测试场景** | 验证 FS 依赖的正向 Lag |
| **前置条件** | 1. 任务 A：结束 1/5<br>2. 依赖：A -> B (FS, Lag=3 天) |
| **测试步骤** | 1. 创建带 Lag 的依赖<br>2. 计算任务 B 的开始时间 |
| **预期结果** | 任务 B 开始时间 = 1/8 (跳过周末后的第 3 个工作日) |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-026 |
| **所属模块** | 智能调度 / Lag 支持 |
| **测试场景** | 验证 Lag 结合工作日历计算 |
| **前置条件** | 1. 任务 A：结束周五 1/10<br>2. 依赖：A -> B (FS, Lag=2 天) |
| **测试步骤** | 1. 计算任务 B 开始时间 |
| **预期结果** | B 开始时间 = 1/15 (周一1/13 + 2工作日延迟 = 周三1/15) |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-027 |
| **所属模块** | 智能调度 / Lag 支持 |
| **测试场景** | 验证 Lag 值边界 - 零值 |
| **前置条件** | 依赖：A -> B (FS, Lag=0) |
| **测试步骤** | 1. 创建 Lag=0 的依赖<br>2. 检查计算结果 |
| **预期结果** | 等同于无 Lag 的 FS 依赖，B 紧随 A 开始 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | SCHED-028 |
| **所属模块** | 智能调度 / Lag 支持 |
| **测试场景** | 验证负 Lag (Lead Time) |
| **前置条件** | 1. 任务 A：1/5-1/10<br>2. 依赖：A -> B (FS, Lag=-2 天) |
| **测试步骤** | 1. 创建负 Lag 依赖<br>2. 计算任务 B 开始时间 |
| **预期结果** | 任务 B 可以在 1/8 开始（A 结束前 2 天即可开始） |
| **优先级** | P1 |

---

## 3. 移动端适配模块 (Mobile Responsive)

### 3.1 视口断点

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-001 |
| **所属模块** | 移动端适配 / 视口断点 |
| **测试场景** | 验证 768px 断点正确触发移动端模式 |
| **前置条件** | 甘特图组件已加载 |
| **测试步骤** | 1. 设置视口宽度为 767px<br>2. 检查是否进入移动端模式 |
| **预期结果** | 移动端模式标志位为 `true`，或相关 CSS 类被添加 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-002 |
| **所属模块** | 移动端适配 / 视口断点 |
| **测试场景** | 验证 768px 及以上保持桌面模式 |
| **前置条件** | 甘特图组件已加载 |
| **测试步骤** | 1. 设置视口宽度为 768px<br>2. 检查是否保持桌面模式 |
| **预期结果** | 移动端模式标志位为 `false`，时间轴正常显示 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-003 |
| **所属模块** | 移动端适配 / 视口断点 |
| **测试场景** | 验证视口变化时模式动态切换 |
| **前置条件** | 当前视口 1024px (桌面模式) |
| **测试步骤** | 1. 将视口从 1024px 缩小到 600px<br>2. 检查是否切换到移动端模式<br>3. 将视口从 600px 放大到 1024px<br>4. 检查是否切换回桌面模式 |
| **预期结果** | 模式随视口变化动态切换 |
| **优先级** | P0 |

---

### 3.2 视图降级

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-004 |
| **所属模块** | 移动端适配 / 视图降级 |
| **测试场景** | 验证移动端隐藏时间轴 |
| **前置条件** | 视口宽度 < 768px |
| **测试步骤** | 1. 进入移动端模式<br>2. 检查时间轴容器的 CSS display 属性 |
| **预期结果** | 时间轴容器 `display: none` |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-005 |
| **所属模块** | 移动端适配 / 视图降级 |
| **测试场景** | 验证移动端 Grid 全宽显示 |
| **前置条件** | 视口宽度 < 768px |
| **测试步骤** | 1. 进入移动端模式<br>2. 测量 Grid 容器宽度 |
| **预期结果** | Grid 容器宽度 = 100% 视口宽度 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-006 |
| **所属模块** | 移动端适配 / 视图降级 |
| **测试场景** | 验证移动端无横向滚动条 |
| **前置条件** | 视口宽度 < 768px |
| **测试步骤** | 1. 进入移动端模式<br>2. 检查页面是否存在横向滚动条 |
| **预期结果** | `document.body.scrollWidth <= document.body.clientWidth`，无横向滚动 |
| **优先级** | P0 |

---

### 3.3 卡片式布局

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-007 |
| **所属模块** | 移动端适配 / 卡片布局 |
| **测试场景** | 验证移动端任务以卡片形式展示 |
| **前置条件** | 1. 视口宽度 < 768px<br>2. 存在多个任务 |
| **测试步骤** | 1. 进入移动端模式<br>2. 检查任务行的 CSS 布局 |
| **预期结果** | 任务以卡片样式显示（具有边框、圆角、间距等卡片特征） |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-008 |
| **所属模块** | 移动端适配 / 卡片布局 |
| **测试场景** | 验证卡片显示必要信息 |
| **前置条件** | 移动端模式，存在任务 |
| **测试步骤** | 1. 检查单个任务卡片内容 |
| **预期结果** | 卡片包含：任务名称 (Task Name)、状态 (Status)、日期 (Date) |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-009 |
| **所属模块** | 移动端适配 / 卡片布局 |
| **测试场景** | 验证卡片垂直排列 |
| **前置条件** | 移动端模式，存在多个任务 |
| **测试步骤** | 1. 检查多个任务卡片的布局方向 |
| **预期结果** | 卡片垂直堆叠排列，形成卡片流 |
| **优先级** | P0 |

---

### 3.4 只读/轻交互

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-010 |
| **所属模块** | 移动端适配 / 只读交互 |
| **测试场景** | 验证移动端禁用拖拽排程 |
| **前置条件** | 视口宽度 < 768px |
| **测试步骤** | 1. 尝试触摸拖拽任务条<br>2. 检查任务是否可被拖动 |
| **预期结果** | 拖拽操作被禁用，任务位置不变 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-011 |
| **所属模块** | 移动端适配 / 只读交互 |
| **测试场景** | 验证移动端支持点击状态切换 |
| **前置条件** | 1. 移动端模式<br>2. 存在状态为"进行中"的任务 |
| **测试步骤** | 1. 点击任务的状态区域<br>2. 选择新状态"已完成" |
| **预期结果** | 任务状态成功切换为"已完成" |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-012 |
| **所属模块** | 移动端适配 / 只读交互 |
| **测试场景** | 验证移动端支持文本编辑 |
| **前置条件** | 移动端模式，存在任务 |
| **测试步骤** | 1. 点击任务名称区域<br>2. 输入新的任务名称<br>3. 确认修改 |
| **预期结果** | 任务名称成功更新 |
| **优先级** | P0 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | MOBILE-013 |
| **所属模块** | 移动端适配 / 只读交互 |
| **测试场景** | 验证移动端禁用依赖连线拖拽 |
| **前置条件** | 移动端模式 |
| **测试步骤** | 1. 尝试从任务端点拖拽创建依赖线 |
| **预期结果** | 依赖连线拖拽功能被禁用 |
| **优先级** | P0 |

---

## 4. 交互体验优化模块 (UX Improvements)

### 4.1 内联编辑

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-001 |
| **所属模块** | 交互优化 / 内联编辑 |
| **测试场景** | 验证双击单元格进入编辑模式 |
| **前置条件** | 存在任务，Grid 显示任务名称列 |
| **测试步骤** | 1. 双击任务名称单元格 |
| **预期结果** | 单元格变为可编辑的 Input 输入框 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-002 |
| **所属模块** | 交互优化 / 内联编辑 |
| **测试场景** | 验证日期列双击弹出 DatePicker |
| **前置条件** | 存在任务，Grid 显示日期列 |
| **测试步骤** | 1. 双击开始日期单元格 |
| **预期结果** | 弹出 DatePicker 组件，可选择日期 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-003 |
| **所属模块** | 交互优化 / 内联编辑 |
| **测试场景** | 验证内联编辑保存 (Enter) |
| **前置条件** | 任务名称处于编辑状态 |
| **测试步骤** | 1. 输入新名称<br>2. 按 Enter 键 |
| **预期结果** | 1. 退出编辑模式<br>2. 新名称被保存 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-004 |
| **所属模块** | 交互优化 / 内联编辑 |
| **测试场景** | 验证内联编辑取消 (Escape) |
| **前置条件** | 任务名称处于编辑状态 |
| **测试步骤** | 1. 输入新名称<br>2. 按 Escape 键 |
| **预期结果** | 1. 退出编辑模式<br>2. 恢复原名称，更改不被保存 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-005 |
| **所属模块** | 交互优化 / 内联编辑 |
| **测试场景** | 验证点击外部区域保存并退出编辑 |
| **前置条件** | 单元格处于编辑状态 |
| **测试步骤** | 1. 输入新内容<br>2. 点击单元格外部区域 |
| **预期结果** | 1. 退出编辑模式<br>2. 内容被保存 |
| **优先级** | P1 |

---

### 4.2 连线交互

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-006 |
| **所属模块** | 交互优化 / 连线交互 |
| **测试场景** | 验证拖拽端点创建依赖 |
| **前置条件** | 存在任务 A 和任务 B，无依赖关系 |
| **测试步骤** | 1. 将鼠标悬停于任务 A 的右端点<br>2. 拖拽连线到任务 B |
| **预期结果** | 成功创建 A -> B 的依赖关系 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-007 |
| **所属模块** | 交互优化 / 连线交互 |
| **测试场景** | 验证拖拽过程中显示预览线 |
| **前置条件** | 开始拖拽创建依赖 |
| **测试步骤** | 1. 从任务 A 端点开始拖拽<br>2. 观察拖拽过程 |
| **预期结果** | 显示跟随鼠标的预览连线 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-008 |
| **所属模块** | 交互优化 / 连线交互 |
| **测试场景** | 验证拖拽到无效区域取消创建 |
| **前置条件** | 开始拖拽创建依赖 |
| **测试步骤** | 1. 从任务 A 端点开始拖拽<br>2. 释放于空白区域（非任务） |
| **预期结果** | 依赖未被创建，预览线消失 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-009 |
| **所属模块** | 交互优化 / 连线交互 |
| **测试场景** | 验证连线创建时触发循环检测 |
| **前置条件** | 存在依赖 A -> B |
| **测试步骤** | 1. 尝试拖拽从 B 到 A 创建依赖 |
| **预期结果** | 1. 循环检测触发<br>2. 依赖创建被阻止<br>3. 显示错误提示 |
| **优先级** | P1 |

---

### 4.3 关键路径高亮

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-010 |
| **所属模块** | 交互优化 / 关键路径 |
| **测试场景** | 验证关键路径开关存在 |
| **前置条件** | 甘特图已加载 |
| **测试步骤** | 1. 查找"显示关键路径"开关控件 |
| **预期结果** | 开关控件存在且可点击 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-011 |
| **所属模块** | 交互优化 / 关键路径 |
| **测试场景** | 验证开启关键路径高亮 |
| **前置条件** | 1. 存在包含依赖关系的任务<br>2. 关键路径开关为关闭状态 |
| **测试步骤** | 1. 点击开启"显示关键路径"开关 |
| **预期结果** | 关键路径上的任务被 CSS 高亮显示 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-012 |
| **所属模块** | 交互优化 / 关键路径 |
| **测试场景** | 验证 CPM 算法计算 Float=0 的任务 |
| **前置条件** | 1. 项目包含多条路径<br>2. 路径 A->B->C 为最长路径<br>3. 路径 D->E 较短 |
| **测试步骤** | 1. 调用关键路径计算方法<br>2. 获取 Float=0 的任务列表 |
| **预期结果** | 返回 [A, B, C]，不包含 D, E |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-013 |
| **所属模块** | 交互优化 / 关键路径 |
| **测试场景** | 验证关闭关键路径高亮 |
| **前置条件** | 关键路径高亮已开启 |
| **测试步骤** | 1. 点击关闭"显示关键路径"开关 |
| **预期结果** | 任务高亮样式被移除，恢复默认显示 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-014 |
| **所属模块** | 交互优化 / 关键路径 |
| **测试场景** | 验证任务变更后关键路径更新 |
| **前置条件** | 1. 关键路径高亮已开启<br>2. 任务 A 在关键路径上 |
| **测试步骤** | 1. 缩短任务 A 的工期，使其脱离关键路径<br>2. 观察高亮变化 |
| **预期结果** | 任务 A 高亮消失，新的关键路径任务被高亮 |
| **优先级** | P1 |

---

| 字段 | 内容 |
|------|------|
| **用例编号** | UX-015 |
| **所属模块** | 交互优化 / 关键路径 |
| **测试场景** | 验证无依赖关系时的关键路径计算 |
| **前置条件** | 项目中所有任务相互独立，无依赖关系 |
| **测试步骤** | 1. 开启关键路径显示<br>2. 检查计算结果 |
| **预期结果** | 所有任务或最长单任务被视为关键路径（取决于业务定义），或提示"无关键路径" |
| **优先级** | P1 |

---

## 附录 A：测试用例统计

| 模块 | P0 用例数 | P1 用例数 | 总计 |
|------|-----------|-----------|------|
| 性能优化 | 7 | 0 | 7 |
| 智能调度引擎 | 24 | 4 | 28 |
| 移动端适配 | 13 | 0 | 13 |
| 交互体验优化 | 0 | 15 | 15 |
| **总计** | **44** | **19** | **63** |

---

## 附录 B：测试数据模板

### B.1 基础任务 Mock 数据结构

```javascript
const mockTask = {
  id: 1,
  text: "任务名称",
  start_date: "2026-01-01",
  end_date: "2026-01-05",
  duration: 5,
  progress: 0.5,
  parent: 0, // 0 表示无父任务
  status: "in_progress" // pending | in_progress | completed
};
```

### B.2 依赖关系 Mock 数据结构

```javascript
const mockLink = {
  id: 1,
  source: 1, // 前置任务 ID
  target: 2, // 后继任务 ID
  type: "0", // 0: FS, 1: SS, 2: FF, 3: SF
  lag: 0 // 延迟天数
};
```

### B.3 1000 任务性能测试数据生成器

```javascript
function generateMockTasks(count = 1000) {
  const tasks = [];
  const baseDate = new Date("2026-01-01");

  for (let i = 1; i <= count; i++) {
    const startOffset = Math.floor(Math.random() * 100);
    const duration = Math.floor(Math.random() * 10) + 1;
    const startDate = new Date(baseDate);
    startDate.setDate(startDate.getDate() + startOffset);
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + duration);

    tasks.push({
      id: i,
      text: `任务 ${i}`,
      start_date: startDate.toISOString().split('T')[0],
      end_date: endDate.toISOString().split('T')[0],
      duration: duration,
      progress: Math.random(),
      parent: i > 10 ? Math.floor(Math.random() * 10) + 1 : 0
    });
  }

  return tasks;
}
```

---

## 附录 C：验收标准映射

| 验收标准 | 对应测试用例 |
|----------|--------------|
| 1000 任务 FPS ≥ 50 | PERF-007 |
| FS/SS 依赖自动更新且跳过周末 | SCHED-001, SCHED-005, SCHED-017, SCHED-018 |
| 父任务自动撑大/收缩 | SCHED-012, SCHED-013 |
| 移动端隐藏 TimeLine，Grid 无横向滚动 | MOBILE-004, MOBILE-006 |

---

*文档结束*
